from pathlib import Path

from luaparser import ast

from .tags import CommentTag, CommentTagSingle, MetadataType, get_tag_line
from .templates import Templates
from .visitor import Visitor


class LuaFile:

    # Docs path
    DocFilePath = "docs"
    TestFilePath = Path("yaml")

    # Footer
    Footer = "_Generated by luaprettydoc {} / {}_"

    def __init__(self, output_dir: Path, filepath: Path,
                 headers_only: bool, debug: bool = False):
        """Scans a Lua file for parsing"""

        __filename = filepath.with_suffix("").name
        self.outname = f"{str(output_dir)}/{__filename}.md"

        if not self.should_update_markdown(__filename, self.outname):
            return

        __tree_info = None
        with open(filepath.resolve(), "r") as file:
            __tree_info = ast.parse(file.read())

        self.filepath = filepath

        # Visit Comments, Methods, and Functions

        visitor = Visitor()
        visitor.visit(__tree_info)

        self.output = True

        # Handle the data
        self.module_brief = "No description available"

        if visitor.has_metadata():
            __metadata = visitor.get_metadata()
            self.create_metadata(__metadata, filepath.name)
        else:
            if headers_only:
                self.output = False

        if visitor.is_empty():
            self.output = False

        # Generate the markdown

        __functions = visitor.get_functions()
        for function_info in __functions:
            self.create_function(function_info)

        # Export info
        if self.output:
            output_dir.mkdir(parents=True, exist_ok=True)

    def should_update_markdown(self, filepath: str, output: str) -> bool:
        """Check if Markdown needs to be re-exported.
        If it doesn't exist yet, return True"""

        lua_file = Path(filepath).resolve()
        markdown = Path(output).resolve()

        if not markdown.exists():
            return True

        return lua_file.stat().st_mtime > markdown.stat().st_mtime

    def is_metadata_valid(self, type: str) -> bool:
        """Check if the Metadata Type is 'Module' or 'Library'"""

        for item in MetadataType:
            if type == item.value:
                return True

        return False

    def create_metadata(self, meta: list, name: str) -> None:
        """Create the Metadata for Markdown Output"""

        module_type, module_name, module_brief = None, None, None

        for metadata in meta:
            if CommentTag.COMMENT_TAG_HEADER in metadata:
                module_type = get_tag_line(metadata, 1)
            elif CommentTag.COMMENT_TAG_NAME in metadata:
                module_name = get_tag_line(metadata, 1) or name
            elif CommentTag.COMMENT_TAG_BRIEF in metadata:
                module_brief = get_tag_line(metadata, 1)

        if not self.is_metadata_valid(module_type):
            module_type = MetadataType.METADATA_TYPE_MODULE

        self.module = f"{module_type} {module_name}"
        self.buffer = Templates.TEMPLATE_START.format(
            self.module, module_brief)

    def handle_parameter_returns(self, line: str) -> str:
        """Handle when we get a @param or @return tag"""

        __param_return = get_tag_line(line, 1)

        if __param_return:
            return Templates.TEMPLATE_RETURN_PARAM.format(__param_return)

        return str()

    def handle_note(self, line: str) -> str:
        """Handle when we get a @note tag"""

        __note = get_tag_line(line, 1)

        if __note is not None:
            return __note

        return str()

    def create_function(self, data: dict) -> None:
        """Creates a Function's markdown data"""

        __args = ", ".join(data["args"])

        __call = None
        __brief, __params = None, ""
        __notes, __returns = list(), ""

        __generate_function = True
        for comment in data["comments"]:
            if CommentTag.COMMENT_TAG_BRIEF in comment:
                if __brief is None:
                    __brief = get_tag_line(comment, 1)
            elif CommentTag.COMMENT_TAG_PARAM in comment:
                __params += self.handle_parameter_returns(comment)
            elif CommentTag.COMMENT_TAG_RETURN in comment:
                __returns += self.handle_parameter_returns(comment)
            elif CommentTag.COMMENT_TAG_NOTE in comment:
                __notes.append(self.handle_note(comment))
            elif CommentTag.COMMENT_TAG_DEFINE in comment:
                if __call is None:
                    __call = Templates.TEMPLATE_DEFINE.format(
                        get_tag_line(comment, 1))
            elif CommentTagSingle.COMMENT_TAG_SINGLE_EXCLUDE in comment:
                __generate_function = False

        if __generate_function:
            if __call is None:
                __call = Templates.TEMPLATE_FUNC.format(
                    source=data["source"], index=data["notation"],
                    name=data["name"], args=__args)

            self.buffer += __call

            if __brief is None:
                __brief = "No description available."

            self.buffer += Templates.TEMPLATE_FUNC_BRIEF.format(__brief)

            if __params:
                self.buffer += Templates.TEMPLATE_PARAMS.format(__params)

            if __returns:
                self.buffer += Templates.TEMPLATE_RETURNS.format(__returns)

            if __notes:
                __notes_joined = " ".join(__notes)
                self.buffer += Templates.TEMPLATE_NOTES.format(__notes_joined)

            self.buffer += Templates.TEMPLATE_ENDING

    def debug_export(self, visitor: Visitor, filepath: Path) -> None:
        """Exports the Lua File to YAML for debug purposes"""

        __directory = Path(LuaFile.TestFilePath)
        if filepath.parent.name != Path().cwd().name:
            __directory = Path(
                f"{LuaFile.TestFilePath}/{filepath.parent.name}")

        __directory.mkdir(parents=True, exist_ok=True)
        __output = __directory / filepath.with_suffix('.yml').name

        with open(__output, "w") as file:
            file.write(visitor.dump_data())

    def export(self, version: str, date: str) -> None:
        """Exports the Lua File to Markdown"""

        if not self.output:
            return

        with open(self.outname, "w", encoding="utf-8") as file:
            print(f"{self.buffer}{LuaFile.Footer.format(version, date)}", file=file)
